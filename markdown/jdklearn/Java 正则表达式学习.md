## Java 正则表达式学习

## 匹配模式
JDK提供三种匹配模式，分别是：贪婪模式(greedy),勉强模式(reluctant)和占有模式(possessive)，分别对应三种占有量词，其中贪婪模式是默认的模式，勉强模式通过在表达式后面加一个？来表示。占有模式通过在表达式后面加一个+来表示。

三种模式的含义是什么呢？

贪婪模式的含义是：尽可能多的匹配，同时也尽量满足整体匹配。
勉强模式的含义是：尽可能少的匹配，同时也尽量满足整体匹配。
占有模式的含义是：尽可能多的匹配，如果因为匹配多了导致整理无法匹配，那么也不会回溯。

比如有个字符串如下：

	/m/t/wd/nl/n/p/m/wd/nl/n/p/m/wd/nl/n/p/m/v/n

贪婪模式的表达式匹配：

	/m/t.*/nl/n/p/m  
    此时匹配结果为 /m/t/wd/nl/n/p/m/wd/nl/n/p/m/wd/nl/n/p/m
勉强模式的表达式匹配：

	/m/t/.*?/nl/n/p/m 
    此时匹配结果为 /m/t/wd/nl/n/p/m
       
	/m/t/wdx+?/nl/n/p/m  
    如果是这样，那么就匹配不上了，因为+表示至少要匹配一个，勉强模式，至少也要匹配一个，所以匹配失败了。
占有模式的表达式匹配：

	/m/t.*+/nl/n/p/m 此时无法匹配，因为.*匹配了过多的字符，导致后面无法匹配是上了。

**注意：只能对可变的匹配规则使用勉强量词或者占有量词。比如X??表示尽量少匹配字符X，而X?却是默认的贪婪模式，此时是尽量多匹配的含义。再如：X{n}的含义是必须准备匹配n个X ，则此时加上其他量词均不起作用**


## 环视（预测）
环视是一个比较高级的主题，但是用起来却是那么自然。
环视适用于这样的场景：做正则匹配时，需要了解被匹配部分的前面或者后面，有或者没有，特定的表达式，而又不因此捕获（消耗）这些特定的表达式。
如果不使用环视，而是直接使用表达式来判断，那么必然会导致这些被匹配的表达式被消耗掉。

举个例子：假设我要给ILoveYou这句话断句，原则是出现大写字母则认为是一个新的单词。

如果使用这个匹配规则：

	\p{Upper}\p{Lower}*[\p{Upper}]?
的话，那么会消耗掉被匹配的大写字母。匹配结果会是：

    IL
    You

这并不符合要求。

解决办法是使用环视，正则表达式为：

	\p{Upper}?\p{Lower}*(?=[\p{Upper}]?)
输出结果为：

	I
	Love
	You
 
环视有四种：
	
    (?=X) 表示后面跟着的是正则表达式X，匹配前面的部分时，不会消耗X这一部分，同时也不会捕获。零宽度正向肯定预测。
    
    (?<=X) 表示前面的是正则表达式X，匹配后面的部分时，不会消耗X这一部分，同时也不会捕获。 零宽度反向肯定预测。
    
     (?!X) 表示后面跟着的不是正则表达式X，匹配前面的部分时，不会消耗X这一部分，同时也不会捕获。零宽度正向否定预测。
     
    (?!=X) 表示前面的不是正则表达式X，匹配后面的部分时，不会消耗X这一部分，同时也不会捕获。 零宽度反向否定预测。
    
## 非捕获占有型匹配

    (?>X) 这个尚未研究清楚。
    
    





